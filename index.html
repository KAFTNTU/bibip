<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>TNTU ENGINEERING SUITE v7.0 [TITAN CLASS]</title>
    
    <style>
        :root {
            --primary: #00ffcc;
            --secondary: #0088aa;
            --alert: #ff3333;
            --warning: #ffaa00;
            --bg: #020202;
            --ui-font: 'Segoe UI', system-ui, sans-serif;
            --mono-font: 'Consolas', 'Monaco', monospace;
        }

        * { box-sizing: border-box; }

        body {
            margin: 0; overflow: hidden; background-color: var(--bg);
            font-family: var(--ui-font); color: var(--primary); user-select: none;
        }

        /* --- SYSTEM BOOT SCREEN --- */
        #boot-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            background: #000; z-index: 99999;
            padding: 40px; display: flex; flex-direction: column;
            font-family: var(--mono-font); font-size: 14px; color: #0f0;
            overflow: hidden;
        }
        
        #boot-log {
            flex-grow: 1; overflow-y: auto; white-space: pre-wrap;
            margin-bottom: 20px; border-bottom: 2px solid #0f0;
            text-shadow: 0 0 5px #0f0;
            scrollbar-width: none;
        }

        #boot-btn {
            padding: 20px; border: 2px solid #0f0; background: #001100;
            color: #0f0; font-family: var(--mono-font); font-size: 18px; font-weight: bold;
            cursor: pointer; text-transform: uppercase; letter-spacing: 2px;
            transition: 0.2s; display: none; text-align: center;
        }
        #boot-btn:hover { background: #0f0; color: #000; box-shadow: 0 0 20px #0f0; }

        /* --- MAIN INTERFACE --- */
        #viewport { position: relative; width: 100vw; height: 100vh; }
        
        #camera-layer {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            object-fit: cover; transform: scaleX(-1);
            filter: grayscale(0.3) contrast(1.1) brightness(0.7);
            z-index: 0;
        }
        
        #ar-layer { position: absolute; top: 0; left: 0; width: 100%; height: 100%; z-index: 10; }

        /* --- HEADS UP DISPLAY --- */
        #hud-container {
            position: absolute; top: 0; left: 0; width: 100%; height: 100%;
            z-index: 20; pointer-events: none;
        }

        .panel {
            position: absolute; background: rgba(5, 15, 20, 0.85);
            border: 1px solid var(--primary); border-radius: 4px;
            padding: 15px; box-shadow: 0 0 15px rgba(0, 255, 204, 0.1);
            backdrop-filter: blur(5px); pointer-events: auto;
        }

        /* Top Right: Status */
        #panel-status {
            top: 20px; right: 20px; width: 280px; text-align: right;
        }
        
        .stat-row { display: flex; justify-content: space-between; margin-bottom: 5px; font-size: 12px; color: #aaa; }
        .stat-val { color: #fff; font-weight: bold; font-family: var(--mono-font); }
        .stat-ok { color: #0f0; } .stat-warn { color: var(--warning); }

        /* Top Center: Task */
        #panel-task {
            top: 20px; left: 50%; transform: translateX(-50%);
            text-align: center; min-width: 300px;
            border-color: var(--warning);
        }
        
        .task-header { font-size: 10px; color: var(--warning); letter-spacing: 3px; margin-bottom: 5px; }
        .task-main { font-size: 16px; font-weight: bold; color: #fff; }

        /* Bottom Left: Logs */
        #panel-log {
            bottom: 20px; left: 20px; width: 300px; height: 150px;
            font-family: var(--mono-font); font-size: 10px; color: #00aa88;
            overflow: hidden; display: flex; flex-direction: column-reverse;
            border-left: 3px solid var(--primary);
        }
        .log-entry { margin-bottom: 2px; opacity: 0.8; }
        .log-err { color: var(--alert); } .log-sys { color: #fff; }

        /* Victory Overlay */
        #win-screen {
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            text-align: center; display: none; z-index: 100;
        }
        .win-title {
            font-size: 60px; color: #0f0; font-weight: 900;
            text-shadow: 0 0 30px #0f0; margin-bottom: 20px;
            animation: pulse 1s infinite;
        }
        @keyframes pulse { 0% {transform: scale(1);} 50% {transform: scale(1.1);} 100% {transform: scale(1);} }

    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>

    <div id="boot-layer">
        <div id="boot-log"></div>
        <div id="boot-btn">ЗАПУСТИТИ СИСТЕМУ</div>
    </div>

    <div id="viewport">
        <video id="camera-layer" playsinline muted></video>
        <canvas id="ar-layer"></canvas>

        <div id="hud-container">
            <div class="panel" id="panel-status">
                <div class="stat-row"><span>SYSTEM:</span> <span class="stat-val stat-ok">ONLINE</span></div>
                <div class="stat-row"><span>PHYSICS:</span> <span class="stat-val stat-ok" id="stat-phys">ACTIVE</span></div>
                <div class="stat-row"><span>AUDIO:</span> <span class="stat-val" id="stat-audio">MUTED</span></div>
                <div class="stat-row"><span>HAND TRACK:</span> <span class="stat-val" id="stat-hand">WAITING...</span></div>
                <div style="margin-top: 10px; border-top: 1px solid #333; paddingTop: 5px;">
                    <div class="stat-row"><span>PARTS:</span> <span class="stat-val" id="stat-parts">0 / 14</span></div>
                </div>
            </div>

            <div class="panel" id="panel-task">
                <div class="task-header">CURRENT OBJECTIVE</div>
                <div class="task-main" id="task-text">Ініціалізація компонентів...</div>
            </div>

            <div class="panel" id="panel-log">
                <div id="log-feed"></div>
            </div>

            <div id="win-screen">
                <div class="win-title">ЗБІРКУ ЗАВЕРШЕНО!</div>
                <div style="color: #fff; font-size: 20px;">СИСТЕМИ ФУНКЦІОНУЮТЬ НОРМАЛЬНО</div>
            </div>
        </div>
    </div>

<script>
/**
 * ============================================================================
 * TNTU ENGINEERING SUITE v7.0 - "TITAN CLASS"
 * Author: Gemini AI
 * Architecture: Entity-Component-System (ECS) Inspired
 * Lines of Code: ~1000 (Generated & Compressed Logic)
 * ============================================================================
 */

// --- 1. GLOBAL CONFIGURATION REGISTRY ---
const CONFIG = {
    // Ядро рендеру
    CORE: { 
        WIDTH: 1280, 
        HEIGHT: 720, 
        FOV: 60,
        MAX_LIGHTS: 4
    },
    // Налаштування фільтрації вводу (1€ Filter)
    FILTER: { 
        FREQ: 60, 
        MIN_CUTOFF: 1.0, 
        BETA: 0.005, 
        D_CUTOFF: 1.0 
    },
    // Фізика взаємодії
    PHYSICS: {
        GRAB_RADIUS: 1.2,        // Радіус захвату
        SNAP_DISTANCE: 0.8,      // Дистанція примагнічування
        LERP_SPEED: 0.15,        // Швидкість слідування деталі за рукою
        ROTATION_SPEED: 4.0      // Швидкість обертання корпусу
    },
    // Вхідні пороги (MediaPipe)
    INPUT: {
        PINCH_START: 0.035,      // Початок щипка
        PINCH_END: 0.050,        // Кінець щипка
        SENSITIVITY: 1.4         // Чутливість курсору
    },
    // Кольорова схема
    THEME: {
        PRIMARY: 0x00ffcc,
        GHOST_VALID: 0x00ff00,
        GHOST_INVALID: 0xff0000,
        CURSOR_IDLE: 0xffff00,
        CURSOR_ACTIVE: 0xff0000,
        CURSOR_LOCK: 0x00aaff
    }
};

// --- 2. AUDIO KERNEL (PROCEDURAL SOUND) ---
class AudioSynthesizer {
    constructor() {
        this.ctx = new (window.AudioContext || window.webkitAudioContext)();
        this.masterGain = this.ctx.createGain();
        this.masterGain.gain.value = 0.3;
        this.masterGain.connect(this.ctx.destination);
        this.enabled = false;
    }

    enable() {
        if (this.ctx.state === 'suspended') this.ctx.resume();
        this.enabled = true;
        document.getElementById('stat-audio').innerText = "ENABLED";
        document.getElementById('stat-audio').className = "stat-val stat-ok";
        this.playBootSound();
    }

    playTone(freq, type, duration, vol = 1.0) {
        if (!this.enabled) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);
        
        osc.connect(gain);
        gain.connect(this.masterGain);
        
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    }

    // SFX PRESETS
    playBootSound() {
        this.playTone(220, 'sine', 0.5);
        setTimeout(() => this.playTone(440, 'sine', 0.5), 100);
        setTimeout(() => this.playTone(880, 'sine', 1.0), 300);
    }

    playHover() { this.playTone(800, 'triangle', 0.05, 0.05); }
    playGrab() { this.playTone(150, 'square', 0.1, 0.2); }
    playSnap() { 
        this.playTone(1200, 'sine', 0.1, 0.3);
        this.playTone(50, 'sawtooth', 0.2, 0.5); // Mechanical thud
    }
    playError() { this.playTone(150, 'sawtooth', 0.3, 0.3); }
    playWin() {
        [440, 554, 659, 880].forEach((f, i) => {
            setTimeout(() => this.playTone(f, 'square', 0.4, 0.4), i * 150);
        });
    }
}

// --- 3. MATH & LOGIC UTILITIES ---
const MathLib = {
    // 1 Euro Filter Implementation classes
    LowPassFilter: class {
        constructor(alpha) { this.setAlpha(alpha); this.y = null; this.s = null; }
        setAlpha(alpha) { this.alpha = alpha; }
        filter(value) {
            if (this.y === null) this.s = value;
            else this.s = this.alpha * value + (1.0 - this.alpha) * this.s;
            this.y = this.s; return this.y;
        }
    },

    OneEuroFilter: class {
        constructor(freq, mincutoff, beta, dcutoff) {
            this.freq = freq; this.mincutoff = mincutoff; this.beta = beta; this.dcutoff = dcutoff;
            this.x = new MathLib.LowPassFilter(this.alpha(mincutoff));
            this.dx = new MathLib.LowPassFilter(this.alpha(dcutoff));
            this.lastTime = null;
        }
        alpha(cutoff) {
            const te = 1.0 / this.freq; const tau = 1.0 / (2 * Math.PI * cutoff);
            return 1.0 / (1.0 + tau / te);
        }
        filter(value, timestamp) {
            if (this.lastTime && timestamp) this.freq = 1.0 / (timestamp - this.lastTime);
            this.lastTime = timestamp;
            const prevX = this.x.y === null ? value : this.x.y;
            const dx = (value - prevX) * this.freq;
            const edx = this.dx.filter(dx); // derivative
            const cutoff = this.mincutoff + this.beta * Math.abs(edx);
            return this.x.filter(value); // signal
        }
    },

    Vector3Filter: class {
        constructor() {
            const f = CONFIG.FILTER;
            this.x = new MathLib.OneEuroFilter(f.FREQ, f.MIN_CUTOFF, f.BETA, f.D_CUTOFF);
            this.y = new MathLib.OneEuroFilter(f.FREQ, f.MIN_CUTOFF, f.BETA, f.D_CUTOFF);
            this.z = new MathLib.OneEuroFilter(f.FREQ, f.MIN_CUTOFF, f.BETA, f.D_CUTOFF);
        }
        process(v, t) {
            return new THREE.Vector3(this.x.filter(v.x, t), this.y.filter(v.y, t), this.z.filter(v.z, t));
        }
    },

    // Projection & Distance helpers
    projectLandmark: (lm, cam, zDepth) => {
        const sens = CONFIG.INPUT.SENSITIVITY;
        const x = ((1 - lm.x) * 2 - 1) * sens;
        const y = (-lm.y * 2 + 1) * sens;
        const vec = new THREE.Vector3(x, y, 0.5);
        vec.unproject(cam);
        const dir = vec.sub(cam.position).normalize();
        const dist = (zDepth - cam.position.z) / dir.z;
        return cam.position.clone().add(dir.multiplyScalar(dist));
    },

    dist2D: (p1, p2, aspect) => {
        const dx = (p1.x - p2.x) * aspect;
        const dy = p1.y - p2.y;
        return Math.sqrt(dx*dx + dy*dy);
    }
};

// --- 4. UI & LOGGING SYSTEM ---
const UI = {
    logEl: document.getElementById('log-feed'),
    taskEl: document.getElementById('task-text'),
    
    log: (msg, type='info') => {
        const d = new Date();
        const time = `${d.getHours()}:${d.getMinutes()}:${d.getSeconds()}`;
        const row = document.createElement('div');
        row.className = `log-entry ${type === 'err' ? 'log-err' : 'log-sys'}`;
        row.innerHTML = `[${time}] ${msg}`;
        UI.logEl.prepend(row);
        if (UI.logEl.children.length > 20) UI.logEl.lastChild.remove();
    },

    setTask: (msg) => {
        UI.taskEl.innerText = msg;
        UI.taskEl.style.color = '#fff';
        setTimeout(() => UI.taskEl.style.color = CONFIG.THEME.PRIMARY, 200);
    },

    updateCounter: (curr, total) => {
        document.getElementById('stat-parts').innerText = `${curr} / ${total}`;
    },

    bootSequence: async (callback) => {
        const log = document.getElementById('boot-log');
        const lines = [
            "INITIALIZING TNTU KERNEL v7.0...",
            "LOADING PHYSICS ENGINE... OK",
            "LOADING AUDIO SYNTHESIZER... OK",
            "CHECKING SENSORS... OK",
            "BUILDING DEPENDENCY GRAPH...",
            "LOADING 3D ASSETS: [GEARS, CHASSIS, PCB, POWER_CELLS]...",
            "SYSTEM READY."
        ];

        for (let line of lines) {
            log.innerHTML += line + "\n";
            log.scrollTop = log.scrollHeight;
            await new Promise(r => setTimeout(r, 300));
        }

        const btn = document.getElementById('boot-btn');
        btn.style.display = 'block';
        btn.onclick = () => {
            document.getElementById('boot-layer').style.display = 'none';
            callback();
        };
    }
};

// --- 5. 3D COMPONENT LIBRARY ---
class ComponentFactory {
    static createPartMesh(type) {
        const group = new THREE.Group();
        let geo, mat, sub;

        switch (type) {
            case 'wheel':
                // Complex Wheel
                geo = new THREE.CylinderGeometry(0.5, 0.5, 0.25, 32);
                geo.rotateX(Math.PI/2);
                mat = new THREE.MeshStandardMaterial({color: 0x111111, roughness: 0.8}); // Tire
                const tire = new THREE.Mesh(geo, mat);
                
                const rimGeo = new THREE.CylinderGeometry(0.25, 0.25, 0.26, 12);
                rimGeo.rotateX(Math.PI/2);
                const rimMat = new THREE.MeshStandardMaterial({color: 0xdddddd, metalness: 0.8});
                const rim = new THREE.Mesh(rimGeo, rimMat);
                
                // Bolts
                for(let i=0; i<4; i++) {
                    const bolt = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.3, 6), rimMat);
                    bolt.rotateX(Math.PI/2);
                    bolt.position.set(Math.cos(i*1.57)*0.15, Math.sin(i*1.57)*0.15, 0);
                    group.add(bolt);
                }
                group.add(tire, rim);
                break;

            case 'axle':
                // Axle rod
                geo = new THREE.CylinderGeometry(0.08, 0.08, 2.0, 12);
                geo.rotateZ(Math.PI/2);
                mat = new THREE.MeshStandardMaterial({color: 0x888888, metalness: 0.5});
                group.add(new THREE.Mesh(geo, mat));
                break;

            case 'motor':
                // Electric Motor
                const body = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 1.0), new THREE.MeshStandardMaterial({color: 0x333333}));
                const coil = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.8, 16), new THREE.MeshStandardMaterial({color: 0xb87333})); // Copper
                coil.rotation.z = Math.PI/2;
                group.add(body, coil);
                break;

            case 'battery':
                // AA Battery
                geo = new THREE.CylinderGeometry(0.15, 0.15, 0.8, 16);
                geo.rotateZ(Math.PI/2);
                mat = new THREE.MeshStandardMaterial({color: 0xddaa00, metalness: 0.4});
                const tip = new THREE.Mesh(new THREE.CylinderGeometry(0.05, 0.05, 0.1, 16), new THREE.MeshStandardMaterial({color: 0xdddddd}));
                tip.rotation.z = Math.PI/2;
                tip.position.x = 0.45;
                group.add(new THREE.Mesh(geo, mat), tip);
                break;

            case 'cover':
                // Battery Cover
                geo = new THREE.BoxGeometry(1.0, 0.05, 1.2);
                mat = new THREE.MeshStandardMaterial({color: 0x222222, roughness: 0.9});
                group.add(new THREE.Mesh(geo, mat));
                break;
                
            case 'spoiler':
                // Racing Spoiler
                const wing = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.1, 0.5), new THREE.MeshStandardMaterial({color: 0xff0000}));
                const legL = new THREE.Mesh(new THREE.BoxGeometry(0.1, 0.4, 0.2), new THREE.MeshStandardMaterial({color: 0x222222}));
                const legR = legL.clone();
                legL.position.set(-0.8, -0.25, 0);
                legR.position.set(0.8, -0.25, 0);
                group.add(wing, legL, legR);
                break;
        }

        // Add invisible hit-box for easier grabbing
        const hitbox = new THREE.Mesh(new THREE.BoxGeometry(1,1,1), new THREE.MeshBasicMaterial({visible: false}));
        hitbox.scale.set(1.5, 1.5, 1.5);
        hitbox.userData = { parentGroup: group };
        group.add(hitbox);

        return group;
    }
}

// --- 6. SCENE MANAGEMENT ---
class SceneManager {
    constructor() {
        this.scene = new THREE.Scene();
        
        // Environment
        this.camera = new THREE.PerspectiveCamera(CONFIG.CORE.FOV, window.innerWidth/window.innerHeight, 0.1, 100);
        this.camera.position.z = 5;
        this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('ar-layer'), alpha: true, antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;

        // Lighting
        const ambi = new THREE.AmbientLight(0xffffff, 0.4);
        this.dirLight = new THREE.DirectionalLight(0xffffff, 1.0);
        this.dirLight.position.set(5, 10, 5);
        this.dirLight.castShadow = true;
        this.scene.add(ambi, this.dirLight);

        // Root Objects
        this.worldRoot = new THREE.Group(); // Rotating container for the car
        this.worldRoot.position.set(0, -1, -6);
        this.scene.add(this.worldRoot);

        this.floatingRoot = new THREE.Group(); // Container for loose parts
        this.floatingRoot.position.set(0, 0, -5);
        this.scene.add(this.floatingRoot);

        // Gizmo
        this.gizmo = this.createGizmo();
        this.scene.add(this.gizmo);
        
        // Cursor
        this.cursor = this.createCursor();
        this.scene.add(this.cursor);
    }

    createGizmo() {
        const g = new THREE.Group();
        g.position.set(3.5, -1, -6);
        
        const sphere = new THREE.Mesh(
            new THREE.IcosahedronGeometry(0.7, 1),
            new THREE.MeshPhongMaterial({color: 0xffaa00, wireframe: true, emissive: 0x331100})
        );
        const core = new THREE.Mesh(
            new THREE.SphereGeometry(0.3),
            new THREE.MeshBasicMaterial({color: 0xff0000})
        );
        const ring = new THREE.Mesh(
            new THREE.TorusGeometry(1.0, 0.02, 16, 64),
            new THREE.MeshBasicMaterial({color: 0x555555})
        );
        
        // Hitbox
        const hit = new THREE.Mesh(new THREE.BoxGeometry(2,2,2), new THREE.MeshBasicMaterial({visible:false}));
        hit.userData = { isGizmo: true };
        
        g.add(sphere, core, ring, hit);
        return g;
    }

    createCursor() {
        const g = new THREE.Group();
        // Red Dot (Bigger)
        const dot = new THREE.Mesh(
            new THREE.SphereGeometry(0.03, 32, 32),
            new THREE.MeshBasicMaterial({color: CONFIG.THEME.CURSOR_ACTIVE, depthTest: false})
        );
        // Brackets
        const ringGeo = new THREE.RingGeometry(0.06, 0.07, 32, 1, 0, Math.PI);
        const mat = new THREE.MeshBasicMaterial({color: CONFIG.THEME.CURSOR_ACTIVE, side: THREE.DoubleSide, depthTest: false, opacity: 0.8, transparent: true});
        const l = new THREE.Mesh(ringGeo, mat); l.rotation.z = Math.PI/2;
        const r = new THREE.Mesh(ringGeo, mat); r.rotation.z = -Math.PI/2;
        
        g.add(dot, l, r);
        g.userData = { l, r, dot, mat };
        g.visible = false;
        return g;
    }

    updateCursor(pos, pinchState) {
        this.cursor.visible = true;
        this.cursor.position.copy(pos);
        
        // Light follows cursor
        this.dirLight.position.x = pos.x + 2;
        this.dirLight.position.y = pos.y + 5;

        // Visuals
        const offset = pinchState ? 0 : 0.08;
        this.cursor.userData.l.position.x = -offset;
        this.cursor.userData.r.position.x = offset;
        
        const col = pinchState ? CONFIG.THEME.CURSOR_LOCK : CONFIG.THEME.CURSOR_ACTIVE;
        this.cursor.userData.dot.material.color.setHex(col);
        this.cursor.userData.mat.color.setHex(col);
    }
}

// --- 7. ASSEMBLY LOGIC ENGINE ---
class AssemblyEngine {
    constructor(sceneManager, audio) {
        this.sm = sceneManager;
        this.audio = audio;
        
        this.parts = [];
        this.snaps = [];
        this.dependencyGraph = {}; // "part_id" -> "required_part_id"
        
        this.buildCarChassis();
        this.scatterParts();
    }

    buildCarChassis() {
        // Main Frame
        const chassis = new THREE.Mesh(
            new THREE.BoxGeometry(1.6, 0.2, 4.0),
            new THREE.MeshStandardMaterial({color: 0x006622, roughness: 0.5, metalness: 0.3})
        );
        this.sm.worldRoot.add(chassis);

        // Define Snap Zones (Ghosts) & Dependencies
        
        // 1. Rear Axle
        this.addSnap('axle', new THREE.Vector3(0, -0.2, 1.2), 'BOT', null, 'axle_rear');
        // 2. Front Axle
        this.addSnap('axle', new THREE.Vector3(0, -0.2, -1.2), 'BOT', null, 'axle_front');
        
        // 3. Wheels (Depend on Axles)
        this.addSnap('wheel', new THREE.Vector3(-1.0, -0.2, 1.2), 'BOT', 'axle_rear');
        this.addSnap('wheel', new THREE.Vector3( 1.0, -0.2, 1.2), 'BOT', 'axle_rear');
        this.addSnap('wheel', new THREE.Vector3(-1.0, -0.2, -1.2), 'BOT', 'axle_front');
        this.addSnap('wheel', new THREE.Vector3( 1.0, -0.2, -1.2), 'BOT', 'axle_front');

        // 4. Motor (Top)
        this.addSnap('motor', new THREE.Vector3(0, 0.4, 1.0), 'TOP', null, 'motor');
        
        // 5. Battery (Bottom)
        this.addSnap('battery', new THREE.Vector3(0.2, -0.15, 0), 'BOT', null, 'bat1');
        this.addSnap('battery', new THREE.Vector3(-0.2, -0.15, 0), 'BOT', null, 'bat2');
        
        // 6. Cover (Depends on Batteries)
        this.addSnap('cover', new THREE.Vector3(0, -0.25, 0), 'BOT', ['bat1', 'bat2']);

        // 7. Spoiler
        this.addSnap('spoiler', new THREE.Vector3(0, 0.5, 1.8), 'TOP');
    }

    addSnap(type, pos, face, depId=null, selfId=null) {
        const snapGroup = new THREE.Group();
        snapGroup.position.copy(pos);
        
        // Ghost geometry
        let geo = new THREE.BoxGeometry(0.5, 0.5, 0.5);
        if(type==='axle') geo = new THREE.CylinderGeometry(0.1, 0.1, 2.0, 8);
        if(type==='axle') snapGroup.rotation.z = Math.PI/2;
        if(type==='wheel') { geo = new THREE.CylinderGeometry(0.5, 0.5, 0.25, 16); snapGroup.rotation.z = Math.PI/2; }
        
        const mat = new THREE.MeshBasicMaterial({color: CONFIG.THEME.GHOST_VALID, wireframe: true, transparent:true, opacity:0.3});
        const mesh = new THREE.Mesh(geo, mat);
        snapGroup.add(mesh);
        
        // Info text
        const canvas = document.createElement('canvas'); canvas.width=128; canvas.height=64;
        const ctx = canvas.getContext('2d');
        ctx.fillStyle='#0f0'; ctx.font='40px Arial'; ctx.fillText(type.toUpperCase(), 10, 50);
        const label = new THREE.Mesh(new THREE.PlaneGeometry(0.5, 0.25), new THREE.MeshBasicMaterial({map: new THREE.CanvasTexture(canvas), transparent:true, side:2}));
        label.position.y = 0.5;
        snapGroup.add(label);

        snapGroup.userData = { 
            type: type, 
            occupied: false, 
            face: face, 
            dep: depId, // ID of dependency
            id: selfId, // Own ID
            mesh: mesh
        };

        this.sm.worldRoot.add(snapGroup);
        this.snaps.push(snapGroup);
        
        // Register dependency state
        if (selfId) this.dependencyGraph[selfId] = false;
    }

    scatterParts() {
        const list = ['axle','axle', 'wheel','wheel','wheel','wheel', 'motor', 'battery','battery', 'cover', 'spoiler'];
        list.forEach((type, i) => {
            const x = (Math.random()-0.5) * 5;
            const y = (Math.random()-0.5) * 3;
            const part = new Part(type, i);
            part.mesh = ComponentFactory.createPartMesh(type);
            part.mesh.position.set(x, y, 0); // Local to floatingRoot
            
            // Add physics data
            part.mesh.userData.part = part;
            part.mesh.userData.velocity = new THREE.Vector3((Math.random()-0.5)*0.01, (Math.random()-0.5)*0.01, 0);
            
            this.sm.floatingRoot.add(part.mesh);
            this.parts.push(part);
        });
        UI.updateCounter(0, list.length);
    }

    // Checking if snap is valid based on dependencies
    isSnapAvailable(snap) {
        if (snap.userData.occupied) return false;
        
        const dep = snap.userData.dep;
        if (!dep) return true; // No dependencies
        
        if (Array.isArray(dep)) {
            // Check all
            return dep.every(id => this.dependencyGraph[id] === true);
        } else {
            // Check single
            return this.dependencyGraph[dep] === true;
        }
    }

    findSnap(pos, type) {
        let best = null;
        let minD = CONFIG.PHYSICS.SNAP_DISTANCE;

        this.snaps.forEach(snap => {
            // Reset visuals
            snap.userData.mesh.material.color.setHex(0x00ff00);
            snap.visible = true;

            // Basic checks
            if (snap.userData.occupied) { snap.visible = false; return; }
            if (snap.userData.type !== type) { snap.visible = false; return; }
            
            // Check dependency
            if (!this.isSnapAvailable(snap)) {
                snap.userData.mesh.material.color.setHex(0xff0000); // Red ghost if dependencies not met
                return; // Can't snap here yet
            }

            // Distance check (World Space)
            const wPos = new THREE.Vector3();
            snap.getWorldPosition(wPos);
            const d = pos.distanceTo(wPos);
            
            if (d < minD) {
                minD = d;
                best = snap;
            }
        });

        if (best) best.userData.mesh.material.color.setHex(0xffff00); // Highlight
        return best;
    }

    installPart(part, snap) {
        this.sm.floatingRoot.remove(part.mesh);
        this.sm.worldRoot.add(part.mesh);
        
        part.mesh.position.copy(snap.position);
        part.mesh.rotation.copy(snap.rotation);
        
        part.isInstalled = true;
        snap.userData.occupied = true;
        snap.visible = false;
        
        // Update dependency graph
        if (snap.userData.id) this.dependencyGraph[snap.userData.id] = true;

        this.audio.playSnap();
        
        // Update Counter
        const installed = this.parts.filter(p => p.isInstalled).length;
        UI.updateCounter(installed, this.parts.length);
        
        if (installed === this.parts.length) {
            this.audio.playWin();
            document.getElementById('win-screen').style.display = 'block';
        }
    }
}

class Part {
    constructor(type, id) {
        this.type = type;
        this.id = id;
        this.isInstalled = false;
        this.mesh = null;
    }
}

// --- 8. MAIN LOOP & INPUT ---
class App {
    constructor() {
        this.sm = new SceneManager();
        this.audio = new AudioSynthesizer();
        this.ae = new AssemblyEngine(this.sm, this.audio);
        this.raycaster = new THREE.Raycaster();
        this.filter = new MathLib.Vector3Filter();
        
        this.state = {
            handPos: new THREE.Vector3(),
            isPinching: false,
            grabbedPart: null,
            isRotating: false,
            lastRotPos: new THREE.Vector3()
        };
    }

    start() {
        const hands = new Hands({locateFile: f => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${f}`});
        hands.setOptions({maxNumHands: 1, minDetectionConfidence: 0.7});
        hands.onResults(this.onHand.bind(this));
        
        const vid = document.getElementById('camera-layer');
        new Camera(vid, {onFrame: async()=>{await hands.send({image:vid})}, width:1280, height:720}).start();
        
        this.loop();
    }

    onHand(res) {
        if (!res.multiHandLandmarks[0]) {
            this.sm.cursor.visible = false;
            document.getElementById('stat-hand').innerText = "LOST";
            document.getElementById('stat-hand').className = "stat-val stat-warn";
            return;
        }
        
        document.getElementById('stat-hand').innerText = "TRACKING";
        document.getElementById('stat-hand').className = "stat-val stat-ok";

        const lm = res.multiHandLandmarks[0];
        const now = performance.now()/1000;
        
        // 1. Position Smoothing
        const rawPos = MathLib.projectLandmark(lm[8], this.sm.camera, -5);
        const pos = this.filter.process(rawPos, now);
        this.state.handPos.copy(pos);

        // 2. Pinch Detect
        const asp = window.innerWidth/window.innerHeight;
        const pinchDist = MathLib.dist2D(lm[8], lm[4], asp);
        const isPinched = pinchDist < CONFIG.INPUT.PINCH_START;
        
        // Visual Update
        this.sm.updateCursor(pos, isPinched);

        // 3. Logic
        if (isPinched && !this.state.isPinching) {
            // PRESS START
            this.handleGrab(pos);
        } else if (!isPinched && this.state.isPinching) {
            // RELEASE
            this.handleRelease();
        }

        // 4. Manipulation
        if (this.state.isRotating) {
            const deltaX = (pos.x - this.state.lastRotPos.x) * CONFIG.PHYSICS.ROTATION_SPEED;
            const deltaY = (pos.y - this.state.lastRotPos.y) * CONFIG.PHYSICS.ROTATION_SPEED;
            
            this.sm.worldRoot.rotation.y += deltaX;
            this.sm.worldRoot.rotation.x += deltaY;
            this.sm.gizmo.rotation.copy(this.sm.worldRoot.rotation); // Sync gizmo visuals
            
            this.state.lastRotPos.copy(pos);
        }

        if (this.state.grabbedPart) {
            // Move part with physics lag
            this.state.grabbedPart.mesh.position.lerp(pos, CONFIG.PHYSICS.LERP_SPEED);
            
            // Highlight snap
            this.state.potentialSnap = this.ae.findSnap(pos, this.state.grabbedPart.type);
        }

        this.state.isPinching = isPinched;
    }

    handleGrab(pos) {
        // Raycast
        const screen = pos.clone().project(this.sm.camera);
        this.raycaster.setFromCamera(new THREE.Vector2(screen.x, screen.y), this.sm.camera);
        
        const hits = this.raycaster.intersectObjects(this.sm.scene.children, true);
        
        for(let hit of hits) {
            // Gizmo
            if (hit.object.userData.isGizmo) {
                this.state.isRotating = true;
                this.state.lastRotPos.copy(pos);
                this.audio.playHover();
                return;
            }
            
            // Part
            // Traverse up to find user data
            let obj = hit.object;
            while(obj.parent && !obj.userData.part) obj = obj.parent;
            
            if (obj.userData.part && !obj.userData.part.isInstalled) {
                this.state.grabbedPart = obj.userData.part;
                this.audio.playGrab();
                UI.setTask(`Перетягую: ${this.state.grabbedPart.type.toUpperCase()}`);
                return;
            }
        }
        this.audio.playError(); // Missed
    }

    handleRelease() {
        if (this.state.isRotating) {
            this.state.isRotating = false;
        }
        
        if (this.state.grabbedPart) {
            if (this.state.potentialSnap) {
                this.ae.installPart(this.state.grabbedPart, this.state.potentialSnap);
                UI.setTask("Деталь встановлено");
            } else {
                UI.setTask("Скидання деталі...");
                this.audio.playError();
            }
            this.state.grabbedPart = null;
        }
    }

    loop() {
        requestAnimationFrame(() => this.loop());
        
        // Idle animation for floating parts
        if (!this.state.grabbedPart) {
            const t = Date.now() * 0.001;
            this.ae.parts.forEach((p, i) => {
                if (!p.isInstalled) {
                    p.mesh.position.y += Math.sin(t + i)*0.002;
                    p.mesh.rotation.z += 0.005;
                }
            });
        }
        
        // Gizmo anim
        this.sm.gizmo.children[0].rotation.y += 0.01;

        this.sm.renderer.render(this.sm.scene, this.sm.camera);
    }
}

// --- BOOT ---
UI.bootSequence(() => {
    const app = new App();
    app.audio.enable();
    app.start();
});

</script>
</body>
</html>
