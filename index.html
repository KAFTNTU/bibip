<!DOCTYPE html>
<html lang="uk">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>TNTU ENGINEERING SUITE v9.0 [TITANIUM]</title>
    
    <style>
        :root {
            --primary-color: #00ffcc;
            --secondary-color: #0088aa;
            --bg-color: #020202;
            --ui-font: 'Segoe UI', system-ui, -apple-system, sans-serif;
            --mono-font: 'Consolas', 'Monaco', monospace;
        }

        * {
            box-sizing: border-box;
            user-select: none;
            -webkit-user-select: none;
        }

        body {
            margin: 0;
            padding: 0;
            overflow: hidden;
            background-color: var(--bg-color);
            font-family: var(--ui-font);
            color: var(--primary-color);
        }

        /* --- ЕКРАН ЗАВАНТАЖЕННЯ --- */
        #boot-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100vw; height: 100vh;
            background: #000;
            z-index: 10000;
            display: flex;
            flex-direction: column;
            justify-content: center;
            align-items: center;
            transition: opacity 0.8s ease-out;
        }

        .loader-ring {
            width: 80px; height: 80px;
            border: 4px solid #111;
            border-top: 4px solid var(--primary-color);
            border-radius: 50%;
            animation: spin 1s infinite cubic-bezier(0.68, -0.55, 0.27, 1.55);
            margin-bottom: 30px;
            box-shadow: 0 0 25px rgba(0, 255, 204, 0.15);
        }

        #boot-log {
            font-family: var(--mono-font);
            color: #008844;
            font-size: 14px;
            text-align: center;
            margin-bottom: 30px;
            min-height: 24px;
            letter-spacing: 1px;
        }

        #btn-launch {
            padding: 16px 60px;
            background: rgba(0, 255, 204, 0.05);
            color: var(--primary-color);
            border: 2px solid var(--primary-color);
            font-size: 18px;
            font-weight: bold;
            letter-spacing: 3px;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.3s ease;
            opacity: 0;
            transform: translateY(20px);
            pointer-events: none;
        }

        #btn-launch.ready {
            opacity: 1;
            transform: translateY(0);
            pointer-events: auto;
        }

        #btn-launch:hover {
            background: var(--primary-color);
            color: #000;
            box-shadow: 0 0 40px var(--primary-color);
        }

        /* --- ОСНОВНИЙ ЕКРАН --- */
        #viewport {
            position: relative;
            width: 100vw;
            height: 100vh;
        }
        
        #video-background {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            object-fit: cover;
            transform: scaleX(-1);
            filter: grayscale(40%) contrast(110%) brightness(60%);
            z-index: 0;
        }

        #webgl-canvas {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 10;
        }

        /* --- HUD (HEADS-UP DISPLAY) --- */
        #hud-layer {
            position: absolute;
            top: 0; left: 0;
            width: 100%; height: 100%;
            z-index: 20;
            pointer-events: none;
        }

        .hud-widget {
            position: absolute;
            top: 30px; right: 30px;
            background: rgba(0, 5, 10, 0.85);
            border: 1px solid var(--primary-color);
            border-radius: 4px;
            padding: 15px 30px;
            backdrop-filter: blur(10px);
            box-shadow: 0 10px 30px rgba(0,0,0,0.5);
        }

        .widget-label {
            font-size: 10px;
            color: #888;
            letter-spacing: 2px;
            margin-bottom: 5px;
            display: block;
        }

        .widget-value {
            font-family: var(--mono-font);
            font-size: 24px;
            font-weight: 700;
            color: #fff;
        }

        .highlight {
            color: var(--primary-color);
        }

        /* --- ЕКРАН ПЕРЕМОГИ --- */
        #victory-screen {
            position: absolute;
            top: 50%; left: 50%;
            transform: translate(-50%, -50%) scale(0.9);
            text-align: center;
            background: rgba(0, 20, 10, 0.95);
            padding: 60px 80px;
            border: 2px solid #00ff00;
            border-radius: 20px;
            box-shadow: 0 0 60px rgba(0, 255, 0, 0.2);
            display: none;
            opacity: 0;
            transition: all 0.6s cubic-bezier(0.34, 1.56, 0.64, 1);
            z-index: 100;
        }

        #victory-screen.active {
            opacity: 1;
            transform: translate(-50%, -50%) scale(1);
            display: block;
        }

        .win-header {
            font-size: 64px;
            margin: 0 0 20px 0;
            color: #00ff00;
            text-shadow: 0 0 30px #00ff00;
            letter-spacing: 5px;
        }

        .win-sub {
            font-size: 24px;
            color: #ccffcc;
            font-family: var(--mono-font);
        }

        @keyframes spin { 0% { transform: rotate(0deg); } 100% { transform: rotate(360deg); } }
    </style>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/hands/hands.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/@mediapipe/camera_utils/camera_utils.js"></script>
</head>
<body>

    <div id="boot-layer">
        <div class="loader-ring"></div>
        <div id="boot-log">ІНІЦІАЛІЗАЦІЯ ЯДРА...</div>
        <button id="btn-launch">ЗАПУСТИТИ СИСТЕМУ</button>
    </div>

    <div id="viewport">
        <video id="video-background" playsinline muted></video>
        <canvas id="webgl-canvas"></canvas>

        <div id="hud-layer">
            <div class="hud-widget">
                <span class="widget-label">СТАТУС ЗБІРКИ</span>
                <div class="widget-value">
                    ДЕТАЛІ: <span id="part-counter" class="highlight">0 / 14</span>
                </div>
            </div>
        </div>

        <div id="victory-screen">
            <h1 class="win-header">УСПІХ!</h1>
            <div class="win-sub">СИСТЕМУ ЗІБРАНО ТА АКТИВОВАНО</div>
        </div>
    </div>

<script>
/**
 * ============================================================================
 * TNTU ENGINEERING SUITE v9.0 "TITANIUM"
 * Comprehensive AR Construction Engine
 * * Modules:
 * 1. Configuration & Constants
 * 2. Advanced Mathematics (Signal Filtering)
 * 3. Audio Synthesis Engine
 * 4. Procedural Model Generation
 * 5. Scene Management
 * 6. Game Logic & State Machine
 * 7. Input Processing & Raycasting
 * 8. Application Core
 * ============================================================================
 */

// --- 1. CONFIGURATION REGISTRY ---
const CONFIG = {
    RENDER: {
        FOV: 60,
        NEAR_CLIP: 0.1,
        FAR_CLIP: 1000,
        SHADOW_MAP_SIZE: 2048
    },
    PHYSICS: {
        ROTATION_SPEED: 2.8,
        LERP_FACTOR: 0.2, // Коефіцієнт згладжування руху деталі
        SNAP_DISTANCE: 0.8, // Дистанція примагнічування
        GRAB_RADIUS: 1.5,
        BOB_SPEED: 0.002, // Швидкість покачування деталей
        BOB_HEIGHT: 0.001
    },
    INPUT: {
        PINCH_THRESHOLD_START: 0.04,
        PINCH_THRESHOLD_END: 0.055,
        CURSOR_SENSITIVITY: 1.45,
        FILTER_FREQUENCY: 60,
        FILTER_MIN_CUTOFF: 1.0,
        FILTER_BETA: 0.007,
        FILTER_DERIVATIVE_CUTOFF: 1.0
    },
    THEME: {
        PRIMARY: 0x00ffcc,
        CHASSIS_COLOR: 0x228822,
        GHOST_VALID: 0x00ff00,
        GHOST_INVALID: 0xff0000,
        GIZMO_IDLE: 0xffaa00,
        GIZMO_ACTIVE: 0xff3300,
        CURSOR_OPEN: 0xff0000,  // Червоний
        CURSOR_CLOSED: 0x00aaff // Синій
    }
};

// --- 2. ADVANCED MATH LIBRARIES ---

/**
 * Low Pass Filter Class
 * Used as a building block for the 1 Euro Filter.
 */
class LowPassFilter {
    constructor(alpha) {
        this.setAlpha(alpha);
        this.y = null;
        this.s = null;
    }

    setAlpha(alpha) {
        if (alpha <= 0 || alpha > 1.0) {
            console.warn("LowPassFilter: alpha should be in (0.0, 1.0]");
        }
        this.alpha = alpha;
    }

    filter(value) {
        if (this.y === null) {
            this.s = value;
        } else {
            this.s = this.alpha * value + (1.0 - this.alpha) * this.s;
        }
        this.y = this.s;
        return this.y;
    }

    lastValue() { 
        return this.y; 
    }
}

/**
 * 1 Euro Filter Class
 * Adaptive filtering for noisy signals (like hand tracking).
 * Minimizes jitter while maintaining low latency during fast movement.
 */
class OneEuroFilter {
    constructor(freq, mincutoff = 1.0, beta = 0.0, dcutoff = 1.0) {
        this.freq = freq;
        this.mincutoff = mincutoff;
        this.beta = beta;
        this.dcutoff = dcutoff;
        this.x = new LowPassFilter(this.alpha(mincutoff));
        this.dx = new LowPassFilter(this.alpha(dcutoff));
        this.lastTime = null;
    }

    alpha(cutoff) {
        const te = 1.0 / this.freq;
        const tau = 1.0 / (2 * Math.PI * cutoff);
        return 1.0 / (1.0 + tau / te);
    }

    filter(value, timestamp) {
        // Update frequency based on timestamp if available
        if (this.lastTime && timestamp) {
            this.freq = 1.0 / (timestamp - this.lastTime);
        }
        this.lastTime = timestamp;
        
        const prevX = this.x.lastValue();
        const dx = (prevX === null) ? 0 : (value - prevX) * this.freq;
        const edx = this.dx.filter(dx);
        
        // Calculate adaptive cutoff
        const cutoff = this.mincutoff + this.beta * Math.abs(edx);
        
        return this.x.filter(value, this.alpha(cutoff));
    }
}

/**
 * Vector3 Filter Wrapper
 * Applies 1 Euro Filter to X, Y, and Z coordinates independently.
 */
class Vector3Filter {
    constructor() {
        const f = CONFIG.INPUT;
        this.xFilter = new OneEuroFilter(f.FILTER_FREQUENCY, f.FILTER_MIN_CUTOFF, f.FILTER_BETA, f.FILTER_DERIVATIVE_CUTOFF);
        this.yFilter = new OneEuroFilter(f.FILTER_FREQUENCY, f.FILTER_MIN_CUTOFF, f.FILTER_BETA, f.FILTER_DERIVATIVE_CUTOFF);
        this.zFilter = new OneEuroFilter(f.FILTER_FREQUENCY, f.FILTER_MIN_CUTOFF, f.FILTER_BETA, f.FILTER_DERIVATIVE_CUTOFF);
    }

    process(vector, timestamp) {
        return new THREE.Vector3(
            this.xFilter.filter(vector.x, timestamp),
            this.yFilter.filter(vector.y, timestamp),
            this.zFilter.filter(vector.z, timestamp)
        );
    }
}

// --- 3. AUDIO SYNTHESIS ENGINE ---

/**
 * AudioEngine Class
 * Generates all sound effects procedurally using WebAudio API.
 * No external files needed.
 */
class AudioEngine {
    constructor() {
        this.context = null;
        this.masterGain = null;
        this.isInitialized = false;
    }

    init() {
        if (this.isInitialized) return;
        
        try {
            const AudioContext = window.AudioContext || window.webkitAudioContext;
            this.context = new AudioContext();
            this.masterGain = this.context.createGain();
            this.masterGain.gain.value = 0.4; // Master volume
            this.masterGain.connect(this.context.destination);
            this.isInitialized = true;
            console.log("AUDIO: Subsystem Initialized");
        } catch (e) {
            console.error("AUDIO: Initialization Failed", e);
        }
    }

    playTone(type, frequency, duration, volume = 1.0, ramp = true) {
        if (!this.isInitialized) return;
        if (this.context.state === 'suspended') this.context.resume();

        const osc = this.context.createOscillator();
        const gain = this.context.createGain();

        osc.type = type; // 'sine', 'square', 'sawtooth', 'triangle'
        osc.frequency.setValueAtTime(frequency, this.context.currentTime);

        gain.gain.setValueAtTime(volume, this.context.currentTime);
        if (ramp) {
            gain.gain.exponentialRampToValueAtTime(0.01, this.context.currentTime + duration);
        }

        osc.connect(gain);
        gain.connect(this.masterGain);

        osc.start();
        osc.stop(this.context.currentTime + duration);
    }

    // --- SFX PRESETS ---

    sfxHover() {
        // Light tick for hovering
        this.playTone('triangle', 800, 0.05, 0.1);
    }

    sfxGrab() {
        // Mechanical engagement sound
        this.playTone('sine', 200, 0.15, 0.3);
        this.playTone('square', 100, 0.1, 0.1);
    }

    sfxSnap() {
        // Satisfying snap sound
        this.playTone('square', 800, 0.1, 0.2);
        setTimeout(() => this.playTone('sine', 60, 0.3, 0.5), 50); // Heavy thud
    }

    sfxRotate() {
        // Motor-like sound
        this.playTone('sawtooth', 100, 0.1, 0.05);
    }

    sfxVictory() {
        // Victory fanfare
        const notes = [523.25, 659.25, 783.99, 1046.50]; // C major arpeggio
        notes.forEach((note, index) => {
            setTimeout(() => {
                this.playTone('square', note, 0.4, 0.3);
                this.playTone('sine', note / 2, 0.4, 0.4); // Bass layer
            }, index * 150);
        });
    }
}

const Audio = new AudioEngine();

// --- 4. PROCEDURAL MODEL FACTORY ---

/**
 * ModelFactory Class
 * Generates 3D meshes for car parts programmatically.
 */
class ModelFactory {
    
    // Material Library
    static getMaterial(type) {
        switch(type) {
            case 'metal': 
                return new THREE.MeshStandardMaterial({
                    color: 0xaaaaaa, metalness: 0.8, roughness: 0.2
                });
            case 'pcb': 
                return new THREE.MeshStandardMaterial({
                    color: 0x004400, roughness: 0.4
                });
            case 'plastic': 
                return new THREE.MeshStandardMaterial({
                    color: 0x222222, roughness: 0.5
                });
            case 'copper': 
                return new THREE.MeshStandardMaterial({
                    color: 0xb87333, metalness: 0.6
                });
            case 'glass': 
                return new THREE.MeshPhongMaterial({
                    color: 0xaaccff, opacity: 0.4, transparent: true, shininess: 90
                });
            case 'battery_body':
                return new THREE.MeshStandardMaterial({
                    color: 0xffaa00, metalness: 0.3, roughness: 0.4
                });
            default: 
                return new THREE.MeshBasicMaterial({color: 0xffffff});
        }
    }

    static createPart(type) {
        const group = new THREE.Group();
        
        switch(type) {
            case 'gear':
                // Procedural Gear
                const gearGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.05, 24);
                const gearMat = this.getMaterial('plastic');
                const gearBody = new THREE.Mesh(gearGeo, gearMat);
                gearBody.rotation.x = Math.PI / 2;
                group.add(gearBody);
                
                // Teeth generation
                const toothGeo = new THREE.BoxGeometry(0.1, 0.05, 0.1);
                for(let i = 0; i < 12; i++) {
                    const tooth = new THREE.Mesh(toothGeo, gearMat);
                    const angle = (i / 12) * Math.PI * 2;
                    tooth.position.set(Math.cos(angle)*0.3, Math.sin(angle)*0.3, 0);
                    tooth.rotation.z = angle;
                    group.add(tooth);
                }
                // Central Hub
                const hub = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 0.06, 12), 
                    this.getMaterial('metal')
                );
                hub.rotation.x = Math.PI / 2;
                group.add(hub);
                break;

            case 'board':
                // PCB Board with Components
                const pcb = new THREE.Mesh(
                    new THREE.BoxGeometry(0.8, 0.05, 0.5), 
                    this.getMaterial('pcb')
                );
                group.add(pcb);
                
                // Microchips
                const chip1 = new THREE.Mesh(new THREE.BoxGeometry(0.2, 0.02, 0.2), this.getMaterial('plastic'));
                chip1.position.set(0.2, 0.04, 0.1);
                group.add(chip1);
                
                const chip2 = new THREE.Mesh(new THREE.BoxGeometry(0.3, 0.02, 0.15), this.getMaterial('plastic'));
                chip2.position.set(-0.15, 0.04, -0.1);
                group.add(chip2);
                break;

            case 'screen':
                // LCD Display
                const frame = new THREE.Mesh(
                    new THREE.BoxGeometry(0.6, 0.05, 0.4), 
                    this.getMaterial('plastic')
                );
                group.add(frame);
                
                const lcd = new THREE.Mesh(
                    new THREE.PlaneGeometry(0.5, 0.3), 
                    new THREE.MeshBasicMaterial({color: 0x00aaff})
                );
                lcd.rotation.x = -Math.PI / 2;
                lcd.position.y = 0.03;
                group.add(lcd);
                break;

            case 'battery':
                // AA Battery
                const batGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.6, 16);
                const bat = new THREE.Mesh(batGeo, this.getMaterial('battery_body'));
                bat.rotation.z = Math.PI / 2;
                
                const posTip = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.05, 0.05, 0.05, 12), 
                    this.getMaterial('metal')
                );
                posTip.rotation.z = Math.PI / 2;
                posTip.position.x = 0.32;
                
                const negTip = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.1, 0.1, 0.02, 12), 
                    this.getMaterial('metal')
                );
                negTip.rotation.z = Math.PI / 2;
                negTip.position.x = -0.31;

                group.add(bat, posTip, negTip);
                break;

            case 'cover_batt':
                // Battery Compartment Cover
                const cov1 = new THREE.Mesh(
                    new THREE.BoxGeometry(0.7, 0.02, 0.5), 
                    this.getMaterial('plastic')
                );
                group.add(cov1);
                break;

            case 'cover_bottom':
                // Main Bottom Cover
                const cov2 = new THREE.Mesh(
                    new THREE.BoxGeometry(1.2, 0.02, 2.5), 
                    this.getMaterial('plastic')
                );
                group.add(cov2);
                
                // Vents detailing
                for(let i = -2; i <= 2; i++) {
                    const vent = new THREE.Mesh(
                        new THREE.BoxGeometry(0.8, 0.03, 0.05), 
                        this.getMaterial('plastic')
                    );
                    vent.position.z = i * 0.3;
                    group.add(vent);
                }
                break;
                
            case 'axle':
                const axle = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.08, 0.08, 2.0, 12),
                    this.getMaterial('metal')
                );
                axle.rotateZ(Math.PI/2);
                group.add(axle);
                break;
                
            case 'wheel':
                // Reusing Gear logic simplified for wheel, or different style
                // For simplicity, reusing structure but larger
                const wGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.25, 32);
                wGeo.rotateX(Math.PI/2);
                const wTire = new THREE.Mesh(wGeo, this.getMaterial('rubber'));
                
                const wRim = new THREE.Mesh(
                    new THREE.CylinderGeometry(0.25, 0.25, 0.26, 16),
                    this.getMaterial('metal')
                );
                wRim.rotateX(Math.PI/2);
                
                group.add(wTire, wRim);
                break;
                
            case 'motor':
                const motBody = new THREE.Mesh(new THREE.BoxGeometry(0.8, 0.6, 1.0), this.getMaterial('plastic'));
                const motCoil = new THREE.Mesh(new THREE.CylinderGeometry(0.3, 0.3, 0.8, 16), this.getMaterial('copper'));
                motCoil.rotation.z = Math.PI/2;
                group.add(motBody, motCoil);
                break;
                
            case 'spoiler':
                const wing = new THREE.Mesh(new THREE.BoxGeometry(2.0, 0.1, 0.5), new THREE.MeshStandardMaterial({color: 0xff0000}));
                group.add(wing);
                break;
        }

        // HITBOX (Invisible interaction volume)
        const hitGeo = new THREE.BoxGeometry(1, 1, 1);
        const hitMat = new THREE.MeshBasicMaterial({visible: false});
        const hitBox = new THREE.Mesh(hitGeo, hitMat);
        
        // Adjust hitbox size based on type
        if (type === 'cover_bottom') hitBox.scale.set(1.5, 0.5, 3);
        else hitBox.scale.set(0.8, 0.8, 0.8);
        
        hitBox.userData = { isPart: true, parentGroup: group };
        group.add(hitBox);

        return group;
    }
}

// --- 5. SCENE GRAPH MANAGER ---

class SceneGraph {
    constructor(renderEngine) {
        this.re = renderEngine;
        
        // 1. World Root (The Object being assembled - Rotates)
        this.worldRoot = new THREE.Group();
        this.worldRoot.position.set(0, -1, -6);
        this.re.scene.add(this.worldRoot);

        // 2. Floating Root (Unassembled parts - Static in space)
        this.floatingRoot = new THREE.Group();
        this.floatingRoot.position.set(0, 0, -5);
        this.re.scene.add(this.floatingRoot);

        // 3. Gizmo (Rotation Control)
        this.gizmo = this.createGizmo();
        this.re.scene.add(this.gizmo);

        // 4. Cursor
        this.cursor = this.createCursor();
        this.re.scene.add(this.cursor);

        this.initChassis();
    }

    createGizmo() {
        const g = new THREE.Group();
        // CENTERED AND LOWER
        g.position.set(0, -3.5, -6); 

        // Sphere
        const geo = new THREE.IcosahedronGeometry(0.8, 1);
        const mat = new THREE.MeshPhongMaterial({
            color: CONFIG.THEME.GIZMO_IDLE,
            wireframe: true,
            emissive: 0x331100
        });
        const sphere = new THREE.Mesh(geo, mat);

        // Rings
        const ring1 = new THREE.Mesh(
            new THREE.TorusGeometry(1.0, 0.02, 32, 64),
            new THREE.MeshBasicMaterial({color: 0x666666})
        );
        const ring2 = ring1.clone();
        ring2.rotation.x = Math.PI / 2;

        // Hitbox
        const hit = new THREE.Mesh(
            new THREE.BoxGeometry(2.5, 2.5, 2.5), 
            new THREE.MeshBasicMaterial({visible: false})
        );
        hit.userData = { isGizmo: true };

        g.add(sphere, ring1, ring2, hit);
        
        // Animation hook
        g.userData.animate = () => {
            sphere.rotation.y += 0.005;
            sphere.rotation.z += 0.002;
        };

        return g;
    }

    createCursor() {
        const g = new THREE.Group();
        
        // Center Dot
        const dot = new THREE.Mesh(
            new THREE.SphereGeometry(0.04, 16, 16),
            new THREE.MeshBasicMaterial({color: CONFIG.THEME.CURSOR_OPEN, depthTest: false})
        );
        
        // Brackets ( )
        const ringGeo = new THREE.RingGeometry(0.08, 0.09, 32, 1, 0, Math.PI);
        const mat = new THREE.MeshBasicMaterial({
            color: CONFIG.THEME.CURSOR_OPEN, 
            side: THREE.DoubleSide, 
            transparent: true, 
            opacity: 0.8,
            depthTest: false
        });
        
        const left = new THREE.Mesh(ringGeo, mat);
        left.rotation.z = Math.PI / 2;
        
        const right = new THREE.Mesh(ringGeo, mat);
        right.rotation.z = -Math.PI / 2;

        g.add(dot, left, right);
        g.userData = { dot, left, right, mat };
        g.visible = false;
        return g;
    }

    initChassis() {
        // Main Green Body
        const geo = new THREE.BoxGeometry(1.6, 0.1, 4.0);
        const mat = new THREE.MeshPhongMaterial({color: CONFIG.THEME.CHASSIS_COLOR, shininess: 80});
        const chassis = new THREE.Mesh(geo, mat);
        this.worldRoot.add(chassis);
        
        // Decorative stripes
        const stripe = new THREE.Mesh(
            new THREE.BoxGeometry(0.2, 0.11, 4.0), 
            new THREE.MeshBasicMaterial({color: 0x111111})
        );
        this.worldRoot.add(stripe);
    }

    updateGizmoState(active) {
        const color = active ? CONFIG.THEME.GIZMO_ACTIVE : CONFIG.THEME.GIZMO_IDLE;
        this.gizmo.children[0].material.color.setHex(color);
        const scale = active ? 1.1 : 1.0;
        this.gizmo.scale.setScalar(scale);
    }

    updateCursorState(pos, pinched) {
        this.cursor.visible = true;
        this.cursor.position.copy(pos);
        
        // Animation of brackets
        const offset = pinched ? 0 : 0.1;
        this.cursor.userData.left.position.x = -offset;
        this.cursor.userData.right.position.x = offset;

        // Color change
        const col = pinched ? CONFIG.THEME.CURSOR_CLOSED : CONFIG.THEME.CURSOR_OPEN;
        this.cursor.userData.dot.material.color.setHex(col);
        this.cursor.userData.mat.color.setHex(col);
    }
}

// --- 6. GAME LOGIC ---

class GameLogic {
    constructor(sceneGraph) {
        this.sg = sceneGraph;
        this.parts = [];
        this.snaps = [];
        this.installedCount = 0;
        this.totalParts = 0;

        this.initLevel();
    }

    initLevel() {
        // --- DEFINE SNAP ZONES & PARTS ---
        
        // 7 Gears (Side mounted)
        this.addGearSet(-0.85, 0); // Left side (3 gears)
        this.addGearSet(0.85, 0);  // Right side (3 gears)
        this.createSnap('gear', new THREE.Vector3(0.85, 0, 1.2), 'SIDE'); // 4th right gear

        // Electronics (Top mounted)
        this.createSnap('board', new THREE.Vector3(0, 0.08, -1.0), 'TOP');
        this.createSnap('screen', new THREE.Vector3(0, 0.08, 0.5), 'TOP');

        // Bottom parts (Batteries & Covers - Need Rotation)
        this.createSnap('battery', new THREE.Vector3(0.2, -0.1, 0.8), 'BOT');
        this.createSnap('battery', new THREE.Vector3(-0.2, -0.1, 0.8), 'BOT');
        this.createSnap('cover_batt', new THREE.Vector3(0, -0.15, 0.8), 'BOT');
        this.createSnap('cover_bottom', new THREE.Vector3(0, -0.12, -0.5), 'BOT');
        
        // Extra parts
        this.createSnap('motor', new THREE.Vector3(0, 0.35, 1.2), 'TOP');
        this.createSnap('spoiler', new THREE.Vector3(0, 0.3, 1.8), 'TOP');
        this.createSnap('axle', new THREE.Vector3(0, -0.2, -1.2), 'BOT'); // Front Axle
        this.createSnap('wheel', new THREE.Vector3(-1.0, -0.2, -1.2), 'BOT'); // Front Left Wheel

        this.spawnLooseParts();
    }

    addGearSet(x, y) {
        const zPositions = [-1.0, 0.0, 1.0];
        zPositions.forEach(z => {
            this.createSnap('gear', new THREE.Vector3(x, y, z), 'SIDE');
        });
    }

    createSnap(type, pos, face) {
        const snap = new THREE.Group();
        snap.position.copy(pos);
        
        // Ghost visualization (Wireframe guide)
        let ghostGeo;
        if(type === 'gear') { 
            ghostGeo = new THREE.CylinderGeometry(0.3, 0.3, 0.05, 16); 
            snap.rotation.x = Math.PI/2; 
        }
        else if(type === 'battery') { 
            ghostGeo = new THREE.CylinderGeometry(0.12, 0.12, 0.6, 12); 
            snap.rotation.x = Math.PI/2; 
            snap.rotation.z = Math.PI/2; 
        }
        else if(type === 'wheel') {
            ghostGeo = new THREE.CylinderGeometry(0.5, 0.5, 0.25, 16);
            snap.rotation.z = Math.PI/2;
        }
        else if(type === 'axle') {
            ghostGeo = new THREE.CylinderGeometry(0.08, 0.08, 2.0, 8);
            snap.rotation.z = Math.PI/2;
        }
        else {
            ghostGeo = new THREE.BoxGeometry(0.5, 0.1, 0.5);
        }

        const ghostMat = new THREE.MeshBasicMaterial({
            color: CONFIG.THEME.GHOST_VALID, 
            wireframe: true, 
            transparent: true, 
            opacity: 0.3
        });
        const ghost = new THREE.Mesh(ghostGeo, ghostMat);
        snap.add(ghost);

        snap.userData = { 
            isSnap: true, 
            type: type, 
            occupied: false,
            mesh: ghost
        };

        this.sg.worldRoot.add(snap);
        this.snaps.push(snap);
        this.totalParts++;
    }

    spawnLooseParts() {
        // Create matching parts for all snaps scattered around
        this.snaps.forEach(snap => {
            const type = snap.userData.type;
            const part = ModelFactory.createPart(type);
            
            // Random scatter position
            const rx = (Math.random() - 0.5) * 6;
            const ry = (Math.random() - 0.5) * 4;
            part.position.set(rx, ry, 0);
            
            part.userData.type = type;
            part.userData.isInstalled = false;
            
            this.sg.floatingRoot.add(part);
            this.parts.push(part);
        });
        
        this.updateCounter();
    }

    updateCounter() {
        const el = document.getElementById('part-counter');
        el.innerText = `${this.installedCount} / ${this.totalParts}`;
        
        if(this.installedCount === this.totalParts) {
            this.triggerWin();
        }
    }

    checkSnap(part, partPos) {
        let bestSnap = null;
        let minDist = CONFIG.PHYSICS.SNAP_DISTANCE;

        for (const snap of this.snaps) {
            if (snap.userData.occupied) continue;
            if (snap.userData.type !== part.userData.type) continue;

            // Get world position of snap (since it rotates with car)
            const snapWorldPos = new THREE.Vector3();
            snap.getWorldPosition(snapWorldPos);

            const dist = partPos.distanceTo(snapWorldPos);
            
            // Visual Feedback: Reset opacities
            snap.userData.mesh.material.opacity = 0.3;
            
            if (dist < minDist) {
                minDist = dist;
                bestSnap = snap;
            }
        }

        if (bestSnap) {
            bestSnap.userData.mesh.material.opacity = 0.8; // Highlight valid snap
        }
        return bestSnap;
    }

    installPart(part, snap) {
        // Move from floating to world root so it rotates with car
        this.sg.floatingRoot.remove(part);
        this.sg.worldRoot.add(part);
        
        // Align transform
        part.position.copy(snap.position);
        part.rotation.copy(snap.rotation);
        
        // Specific rotation fixes
        if(part.userData.type === 'gear') part.rotation.x = Math.PI/2;
        if(part.userData.type === 'battery') { part.rotation.x = 0; part.rotation.z = Math.PI/2; }
        if(part.userData.type === 'wheel') part.rotation.z = Math.PI/2;
        if(part.userData.type === 'axle') part.rotation.z = Math.PI/2;

        part.userData.isInstalled = true;
        snap.userData.occupied = true;
        snap.visible = false; // Hide ghost

        this.installedCount++;
        this.updateCounter();
        Audio.sfxSnap();
    }

    triggerWin() {
        Audio.sfxVictory();
        document.getElementById('victory-screen').classList.add('active');
        
        // Confetti simulation (Background Flash)
        let i = 0;
        const interval = setInterval(() => {
            const colors = ['#003300', '#000033', '#330000', '#333300'];
            document.body.style.backgroundColor = colors[i % 4];
            i++;
            if(i > 8) {
                clearInterval(interval);
                document.body.style.backgroundColor = '#020202';
            }
        }, 200);
    }
}

// --- 7. INPUT SYSTEM ---

class InputSystem {
    constructor(game, sceneGraph) {
        this.game = game;
        this.sg = sceneGraph;
        this.raycaster = new THREE.Raycaster();
        this.filter = new Vector3Filter();
        
        this.state = {
            handPos: new THREE.Vector3(),
            isPinching: false,
            grabbedObject: null,
            potentialSnap: null,
            isRotating: false,
            lastRotPos: new THREE.Vector3()
        };
    }

    update(landmarks, camera) {
        const now = performance.now() / 1000;
        
        // 1. Calculate and Filter Position
        const s = CONFIG.INPUT.CURSOR_SENSITIVITY;
        const x = ((1 - landmarks[8].x) * 2 - 1) * s;
        const y = (-landmarks[8].y * 2 + 1) * s;
        
        const rawVec = new THREE.Vector3(x, y, 0.5);
        rawVec.unproject(camera);
        const dir = rawVec.sub(camera.position).normalize();
        const dist = (-5 - camera.position.z) / dir.z; // Project to Z = -5
        const rawPos = camera.position.clone().add(dir.multiplyScalar(dist));

        const pos = this.filter.process(rawPos, now);
        
        // 2. Pinch Detection
        const asp = window.innerWidth / window.innerHeight;
        const pinchDist = Math.sqrt(
            Math.pow((landmarks[8].x - landmarks[4].x) * asp, 2) + 
            Math.pow(landmarks[8].y - landmarks[4].y, 2)
        );
        const isPinched = pinchDist < CONFIG.INPUT.PINCH_THRESHOLD_START;
        
        // 3. Update Visuals
        this.sg.updateCursorState(pos, isPinched);

        // 4. State Machine Logic
        if (isPinched && !this.state.isPinching) {
            this.onGrabStart(pos, camera);
        } else if (!isPinched && this.state.isPinching) {
            this.onGrabEnd();
        }

        // 5. Manipulation Logic
        if (this.state.isRotating) {
            this.handleRotation(pos);
        } else if (this.state.grabbedObject) {
            this.handleDrag(pos);
        }

        this.state.isPinching = isPinched;
        this.state.handPos.copy(pos);
    }

    onGrabStart(pos, camera) {
        // Raycast
        const screen = pos.clone().project(camera);
        this.raycaster.setFromCamera(new THREE.Vector2(screen.x, screen.y), camera);
        
        // Check Gizmo
        const gizmoHits = this.raycaster.intersectObjects(this.sg.gizmo.children);
        if (gizmoHits.length > 0) {
            this.state.isRotating = true;
            this.state.lastRotPos.copy(pos);
            this.sg.updateGizmoState(true);
            Audio.sfxHover();
            return;
        }

        // Check Parts (Only interact with floating parts)
        const partHits = this.raycaster.intersectObjects(this.sg.floatingRoot.children, true);
        
        for (let hit of partHits) {
            let obj = hit.object;
            // Traverse up to find root group of part
            while(obj.parent && obj.parent !== this.sg.floatingRoot) {
                obj = obj.parent;
            }
            
            if (obj.userData.type && !obj.userData.isInstalled) {
                this.state.grabbedObject = obj;
                Audio.sfxGrab();
                return;
            }
        }
    }

    onGrabEnd() {
        if (this.state.isRotating) {
            this.state.isRotating = false;
            this.sg.updateGizmoState(false);
        }

        if (this.state.grabbedObject) {
            if (this.state.potentialSnap) {
                this.game.installPart(this.state.grabbedObject, this.state.potentialSnap);
            }
            this.state.grabbedObject = null;
            this.state.potentialSnap = null;
        }
    }

    handleRotation(pos) {
        const dx = (pos.x - this.state.lastRotPos.x) * CONFIG.PHYSICS.ROTATION_SPEED;
        const dy = (pos.y - this.state.lastRotPos.y) * CONFIG.PHYSICS.ROTATION_SPEED;
        
        this.sg.worldRoot.rotation.y += dx;
        this.sg.worldRoot.rotation.x += dy;
        
        // Sync gizmo visuals
        this.sg.gizmo.children[0].rotation.y += dx;
        this.sg.gizmo.children[0].rotation.x += dy;
        
        this.state.lastRotPos.copy(pos);
        
        if(Math.abs(dx) > 0.05) Audio.sfxRotate();
    }

    handleDrag(pos) {
        // Physics lerp
        this.state.grabbedObject.position.lerp(pos, CONFIG.PHYSICS.LERP_FACTOR);
        
        // Check snaps
        this.state.potentialSnap = this.game.checkSnap(this.state.grabbedObject, pos);
    }
}

// --- 8. RENDER ENGINE ---

class RenderEngine {
    constructor() {
        this.scene = new THREE.Scene();
        this.scene.fog = new THREE.FogExp2(0x000000, 0.02);

        this.camera = new THREE.PerspectiveCamera(CONFIG.RENDER.FOV, window.innerWidth/window.innerHeight, 0.1, 100);
        this.camera.position.z = 5;

        this.renderer = new THREE.WebGLRenderer({ canvas: document.getElementById('webgl-canvas'), alpha: true, antialias: true });
        this.renderer.setSize(window.innerWidth, window.innerHeight);
        this.renderer.shadowMap.enabled = true;

        this.initLights();
        this.handleResize();
    }

    initLights() {
        const ambi = new THREE.AmbientLight(0xffffff, 0.6);
        this.scene.add(ambi);

        const dir = new THREE.DirectionalLight(0xffffff, 1.2);
        dir.position.set(5, 10, 7);
        dir.castShadow = true;
        this.scene.add(dir);
    }

    handleResize() {
        window.addEventListener('resize', () => {
            this.camera.aspect = window.innerWidth / window.innerHeight;
            this.camera.updateProjectionMatrix();
            this.renderer.setSize(window.innerWidth, window.innerHeight);
        });
    }

    render() {
        this.renderer.render(this.scene, this.camera);
    }
}

// --- 9. APPLICATION CORE ---

class Application {
    constructor() {
        this.render = new RenderEngine();
        this.sg = new SceneGraph(this.render);
        this.game = new GameLogic(this.sg);
        this.input = new InputSystem(this.game, this.sg);
    }

    start() {
        const hands = new Hands({locateFile: (file) => `https://cdn.jsdelivr.net/npm/@mediapipe/hands/${file}`});
        hands.setOptions({
            maxNumHands: 1,
            modelComplexity: 1,
            minDetectionConfidence: 0.7,
            minTrackingConfidence: 0.7
        });

        hands.onResults((results) => {
            if (results.multiHandLandmarks && results.multiHandLandmarks.length > 0) {
                this.input.update(results.multiHandLandmarks[0], this.render.camera);
            } else {
                this.sg.cursor.visible = false;
            }
        });

        const videoEl = document.getElementById('video-background');
        const camera = new Camera(videoEl, {
            onFrame: async () => { await hands.send({image: videoEl}); },
            width: 1280, height: 720
        });
        
        camera.start();
        this.gameLoop();
    }

    gameLoop() {
        requestAnimationFrame(() => this.gameLoop());
        
        // Idle Animation for floating parts
        const t = Date.now() * 0.001;
        this.sg.floatingRoot.children.forEach((child, i) => {
            if (child !== this.input.state.grabbedObject) {
                child.position.y += Math.sin(t + i) * CONFIG.PHYSICS.BOB_HEIGHT;
                child.rotation.z += CONFIG.PHYSICS.BOB_SPEED;
            }
        });

        // Idle Animation for Gizmo
        if (this.sg.gizmo.userData.animate) {
            this.sg.gizmo.userData.animate();
        }

        this.render.render();
    }
}

// --- BOOTSTRAP ---

window.onload = () => {
    const log = document.getElementById('boot-log');
    const steps = [
        "ЗАВАНТАЖЕННЯ ЯДРА...", 
        "ІНІЦІАЛІЗАЦІЯ ФІЗИКИ...", 
        "ПІДГОТОВКА ГРАФІКИ...", 
        "ГОТОВО ДО РОБОТИ."
    ];
    let i = 0;

    const interval = setInterval(() => {
        if (i < steps.length) {
            log.innerText = steps[i];
            i++;
        } else {
            clearInterval(interval);
            document.querySelector('.loader-ring').style.display = 'none';
            const btn = document.getElementById('btn-launch');
            btn.classList.add('ready');
            
            btn.onclick = () => {
                Audio.init(); // Must be triggered by user interaction
                document.getElementById('boot-layer').style.opacity = '0';
                setTimeout(() => {
                    document.getElementById('boot-layer').style.display = 'none';
                    const app = new Application();
                    app.start();
                }, 800);
            };
        }
    }, 600);
};

</script>
</body>
</html>
